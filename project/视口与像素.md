
### 布局视口 layout viewport

网页布局的区域，它是 `html` 元素的父容器，只要不在 `css` 中修改 `html` 元素的宽度， `html` 元素的宽度就会撑满 布局视口的宽度。

很多时候浏览器窗口没有办法显示出布局视口的全貌，但是它确实是已经被加载出来了，这个时候滚动条就出现了，你需要通过滚动条来浏览布局视口其他的部分。  

布局视口用 css 像素来衡量尺寸，在缩放、调整浏览器窗口的时候不会改变。缩放、调整浏览器窗口改变的只是视觉视口。

在桌面浏览器中，缩放100% 的时候，布局视口宽度等于内容窗口的宽度。（几乎不会在电脑上见过横向滚动条，除非你调整缩放）  

但是在移动端，缩放为 100% 的时候，布局视口不一定等于内容窗口的大小。

当用手机浏览宽大的网页（这些网页没有采用响应式设计）的时候，只能浏览网页的一个部分，然后通过手指滑动浏览其他部分。这就说明整个网页已经加载出来了，只不过你要一部分一部分地看。


### 视觉视口 visual viewport

显示在屏幕上的网页区域，它往往只显示布局视口的一部分。

视觉视口就像一台摄像机，布局视口就像一张纸，摄像机对准纸的哪个部分，就能看见哪个部分。可以改变摄像机的拍摄区域大小（调整浏览器窗口大小），也可以调整摄像机的距离（调整缩放比例），这些方法都可以改变视觉视口，但是布局视口始终不变。


### 理想视口 ideal viewport

不同的设备有自己不同的理想视口，理想视口的宽度等于移动设备的屏幕宽度，所以是最适合移动设备的视口。

只要在 `css` 中把某一元素的宽度设为理想视口的宽度（单位用 `px` ），那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100% 的效果。

理想视口的意义在于，无论在何种分辨率的屏幕下，那些针对理想视口而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。


### 利用 meta 标签对 viewport 进行控制

移动设备默认的 viewport 是 layout viewport，也就是那个比屏幕要宽的 viewport，但在进行移动设备网站的开发时，需要的是 ideal viewport。那么怎么才能得到 ideal viewport 呢？ 

在开发 h5 页面时，最经常见的标签如下所示：

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
```

该 meta 标签的作用是让当前 viewport 的宽度等于设备的宽度，同时不允许用户手动缩放。

如果你不这样的设定的话，那就会使用那个比屏幕宽的默认 viewport（layout viewport），也就是说会出现横向滚动条。

| 参数 | 描述 | 
| -------------- | -------------- | 
| width | 设置 layout viewport 的宽度，为一个正整数，或字符串 "width-device" |
| height | 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用 |
| initial-scale | 设置页面的初始缩放值，为一个数字，可以带小数 |
| minimum-scale | 允许用户的最小缩放值，为一个数字，可以带小数 |
| maximum-scale | 允许用户的最大缩放值，为一个数字，可以带小数 |
| user-scalable | 是否允许用户进行缩放，值为"no"或"yes", no 代表不允许，yes 代表允许 |


### 物理像素

又称设备像素，是设备上最微小的物理元件。


### 设备独立像素

是操作系统定义的一种像素单位，应用程序将设备独立像素告诉操作系统，操作系统再将设备独立像素转化为设备像素，从而控制屏幕上真正的物理像素点。

> 为什么要在应用程序与设备像素之间定义这种单位？为什么应用程序不直接使用设备像素？

例如原先在 1280×720 设备分辨率的显示屏中，显示高度为 12 个设备像素的字体，现在放到设备分辨率为 2560 ×1440 的显示屏中，如果要想得到原先的大小，则需要 24 个设备像素。

如果应用程序直接使用设备像素，那么编写应用程序则将变得非常困难。

需要编写应用程序逻辑：字体在一些屏幕上高度为 12 个设备像素，在另一些屏幕上却需要 24 个设备像素。

因此操作系统定义了一个单位：设备独立像素。操作系统保证：用设备独立像素定义的尺寸，不管屏幕的参数如何，都能以合适的大小显示。

> 操作系统是如何做到的呢？

对于那些像素密度高的屏幕，将多个设备像素划分为一个逻辑像素。至于将多少设备像素划分为一个设备独立像素，这由操作系统决定。

设备独立像素与设备像素之间的比例是多少，显示器厂商和操作系统厂商会通过调查研究来得出最利于观看的比例。普遍规律是，屏幕的像素密度越高，就需要更多的设备像素来显示一个设备独立像素。 ​


### css 像素

一个抽象单位，主要使用在浏览器上，用来精确度量 web 页面上的内容，一般情况下又称 `css` 像素为设备无关像素（DIPs）。

在 css 中使用的 `px` 都是指 css 像素，比如 `width: 128px`。

css 像素的大小是很容易变化的，当我们缩放页面的时候，元素的 css 像素数量不会改变，改变的只是每个 css 像素的大小。

也就是说 `width: 128px` 的元素在缩放 200% 以后，宽度依然是 128 个 css 像素，只不过每个 css 像素的宽度和高度变为原来的两倍。如果原本元素宽度为 128 个设备独立像素，那么缩放 200% 以后元素宽度为 256 个设备独立像素。 ​

> css 像素与设备独立像素的关系？

- 缩放比例就是 css 像素边长 / 设备独立像素边长；

- 在缩放比例为 100% 的情况下，1 个 css 像素大小等于 1 个设备独立像素；

- 在缩放比例为 200% 的情况下，1 个 css 像素大小等于 (2 * 2) 个设备独立像素；

> css 像素与设备像素的关系？

在 `javascript` 中可以通过 `window.devicePixelRatio` 获取到当前设备的设备像素比，简称 dpr 。

可以这样计算：`devicePixelRatio` = （在相同长度的直线上）设备像素的数量 / css 像素的数量。

这个比例也等价于 css 像素边长 / 设备像素边长。

如 `devicePixelRatio` = 2，表示在相同长度的直线上，设备像素的数量是 css 像素数量的 2 倍。

因此 css 像素的边长是设备像素边长的 2 倍。

缩放会导致 css 像素边长的改变，从而导致 `window.devicePixelRatio` 的改变！



css单位rem
rem是相对根元素<HTML>的字体大小来计算的
<html style="font-size="16px";"></html> ，此时 1rem = 16px



/*********/
项目应用
/*********/

该方案核心目的
动态改写 <meta> 标签
给 <html> 元素添加 data-dpr 属性，并且动态改写 data-dpr 的值
给 <html> 元素添加 font-size 属性，并且动态改写 font-size 的值

结合实际项目改写部分代码
实际项目中没有用到 css 预处理器
项目前后端耦合，采用的 idea 或 eclipse 编辑器，暂不知道是否有类似 px2rem 的插件
设计稿采用的是 750 宽度的视觉稿，手淘方案中 iphone6 的 1rem = 75px ，不方便单位换算
为了开发效率，做了一下改进，思路如下
目标是为了能将设计稿量出来的尺寸直接除 100 得到正确的 rem ，即假设 1rem = 100px
根据设计稿可以看出，布局视口最大宽度是 750 / 100 = 7.5rem
假设现有宽度 150px 的盒子需要换算，设计稿的宽度是实际屏幕的 2 倍，实际此盒子占屏幕宽度 150 / 2 = 75px
又假设当前计算出来的 <html> 元素的字体大小是 100px ，得出的宽度就是 width = 0.75rem ，不是预设目标，中间做了除 2 的运算
0.75rem 乘 2 刚好是我们想要结果 1.5rem ，根据如下计算步骤 75 / 100 * 2 = 1.5rem ，约分得出 75 / 50 = 1.5rem
所以如果此时的 <html> 元素的字体大小是 50px ，正好满足目标
需要根据设备的宽度动态计算 <html> 元素的字体大小
在iphone6中设备的宽度是 375 ，而 设备宽度与理想中 <html> 元素的字体大小比值，正好等于 7.5rem ，即 375 / 50 === 750 / 100
由此可以得出计算 <html> 元素的字体大小的公式 font-size = 设备宽度 / ( 设计稿宽度 / 100 )
这样不论设计稿宽度是多少，都能将量出的尺寸除 100 得到正确的 rem
项目中 meta 标签采用固定值，未动态计算 initial-scale 值

1px边框问题
手淘适配方案中根据屏幕的 dpr 动态设置了 initial-scale ，1px 边框因为缩放可以正确显示
项目中设置了固定的缩放值，1px 的线条会较粗
定义了关于边框的公共样式，部分如下
.border-1px{
  position:relative;
  width:100%;
}
.border-1px:after{
  content:'';
  position:absolute;
  width:100%;
  border-bottom:1px solid #333;
  left:0;
  bottom:0;
  transform:scaleY(.5);
}

图片高清化
根据 dpr 的值来动态修改图片加载路径
或者将设备的 dpr 值返回给后台，由后台处理返回图片的路径
需要注意的是使用 img 标签时，设置好 width 和 height 属性，减少页面布局在更改图片时性能消耗

背景图高清化
使用媒体查询为不同 dpr 设备加载不同背景图，部分代码如下
@media only screen and (-Webkit-min-device-pixel-ratio: 1.5),
only screen and (-moz-min-device-pixel-ratio: 1.5),
only screen and (-o-min-device-pixel-ratio: 3/2),
only screen and (min-device-pixel-ratio: 1.5) {
  .icon {
    background-image: url(example@2x.png);
  }
}

响应式图片
** 使用 max-width : 100% ，可以根据容器的大小缩放或者放大图像，并且图像的宽高比保持不变。
视频和其他富媒体上也可以使用
img, embed, object, video { max-width: 100%; }
在一些浏览器中仅指定图片的宽度，可能会导致浏览器重新处理布局，调整页面的时间周期会增加两到三倍
虽然周期不到一毫秒，但是累积起来，尤其是页面上有很多个这样的元素的时候，还是或多或少会影响页面的性能。为了解决这个问题，可以显式的指定图片的height值为auto
** 配合 background-image 和 background-size 一起使用
固定纵横比例
为了保持背景图片的纵横比例，需要基于宽度来计算 padding-top 或者 padding-bottom 的值
padding-top / padding-bottom = （背景图片高度 / 背景图片宽度） * 100%
自适应纵横比例
同一张图片根据设备不同（或者布局不同）显示不同的比例
需要知道各种比例的宽高
假设我们的大图尺寸是700像素宽度和267像素高，而我们决定显示的图片尺寸是在300像素宽度和167像素的高度。现在我们需要计算高度 height 和内距 padding-top 或 padding-bottom 的值
计算坡度，也就是 padding-top / padding-bottom ，也就是自适应那部分的高度 s = (h2 - h1) / (w2 - w1)
计算固定的开始高度 h = h1 - s * w1


https://juejin.cn/post/7046169975706353701