HTTP 缓存会存储与请求关联的响应，并将存储的响应复用于后续请求。

cache-control
用于在HTTP请求和响应的消息头中通过指令来实现缓存机制。缓存指令是单向的，意味着在请求设置的指令，在响应中不一定包含相同指令
指令不区分大小写，指令间用逗号分隔
--- 可缓存性 ---
public   表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存
private  表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）
no-cache 会发起往返通信来验证缓存的响应，但如果资源未发生变化，则使用缓存
--- 到期 ---
max-age=<seconds>  设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)
s-maxage=<seconds> 仅适用与共享缓存（代理服务器），会覆盖max-age
max-stale[=<seconds>] 发出请求方设置项，表明客户端愿意接收一个已经过期的资源。 可选的设置一个时间(单位秒)，表示过期资源的最大过期时间，超过后不使用缓存
--- 重新验证/加载 ---
must-revalidate 使用缓存前必须验证，且不可使用过期缓存
proxy-revalidate 与must-revalidate作用相同，仅适用与代理服务器
--- 其他 ---
no-store 直接禁止浏览器以及所有代理服务器缓存任何响应
no-transform 不得对资源进行转换或转变

存在cache-control头且需要进行资源验证需要以下头进行验证
last-modified 
服务器认定的上次修改时间，存在响应头中，第二次请求资源时，会在请求头中带上if-modified-since，用于询问服务器文件在此时间后，是否修改过
etag
是资源的特定版本的标识符，数据签名，存在响应头中，第二次请求资源时，会在请求头中带上if-match或者if-none-match头，它们的值是服务器带来的etag的值，服务器对比资源的签名，判断是否适用缓存
expires
响应头中带有的标识缓存过期时间的头，返回的时间是服务器时间，如果客户端的时间与服务器的时间相差很大，就会存在很大误差。在过期时间前，客户端不会发起请求去获取数据，直接使用缓存中数据。如果存在cache-control:max-age会被替代。
